### HAOI2018coloring sol

#### 评测地址

* [loj 2527](<https://loj.ac/problem/2527>)
* [luogu 4491](<https://www.luogu.com.cn/problem/P4491>)



#### sol

这里是基础预备知识..

$$
all=m^n\\

\frac{n!}{\prod (a_i!)}\quad (\sum a_i=n)\\
F(x)=\sum_{i=0}^n \frac{x^i}{i!}\quad \sum_{0\leq i}\frac{x^i}{i!}=e^x
$$

我们考虑求出这样一个东西$qwq(k)$使得$(\sum_{i=1}^m [a_i=S])=k$即贡献为$w_k$的序列计数.



设$T(p)$为序列$p$中出现数量为$S$的颜色集合$T_p=\{x\in[1,m]\mid cnt(x,p)=S\}$.

设$F(S)=\{p|T(p)=S\}​$,而$G(S)=\{p|S\subset T(p)\}​$.

显然由于不同颜色是对等的$F(S),G(S)$的值只与$|S|$有关.

设$F(S)=f(|S|),G(S)=g(|S|)$.



$$
g(k)
=[x^n]((\frac{x^S}{S!})^ke^{(m-k)x})
=(S!)^{-k}[x^{n-kS}]e^{(m-k)x}
=\frac{(m-k)^{n-kS}}{(S!)^k(n-kS)!}\\
G(S)=\sum_{S\subset T}F(T)=\sum_{T\subset([1,m]\setminus S)}F(S\cup T)\\
g(k)=\sum_{i=k}^m\binom{m-k}{i-k}f(i)
$$

考虑进行二项式反演,直接给出结论与证明,略过容斥系数求解(可以用多项式求逆,组合意义,矩阵求逆来做,甚至可以直接打表找规律).
$$
f(k)
=\sum_{i=k}^m \binom{m-k}{i-k}(-1)^{i-k}g(i)\\
=\sum_{i=k}^m \binom{m-k}{i-k}(-1)^{i-k}\sum_{j=i}^m\binom{m-i}{j-i}f(j)\\
=\sum_{i=k}^m\sum_{j=i}^m \binom{m-k}{i-k}(-1)^{i-k}\binom{m-i}{j-i}f(j)\\
=\sum_{j=k}^m\sum_{i=k}^j \binom{m-k}{i-k}(-1)^{i-k}\binom{m-i}{j-i}f(j)\\
=\sum_{j=k}^mf(j)\sum_{i=k}^j \binom{m-k}{i-k}(-1)^{i-k}\binom{m-i}{j-i}\\
=\sum_{j=k}^mf(j)\sum_{i=k}^j \binom{m-k}{m-j}\binom{j-k}{i-k}(-1)^{i-k}\\
=\sum_{j=k}^mf(j)\binom{m-k}{m-j}\sum_{i=0}^{j-k}\binom{j-k}{i}(-1)^i\\
=\sum_{j=k}^mf(j)\binom{m-k}{m-j}(1-1)^{j-k}\\
=\sum_{j=k}^mf(j)\binom{m-k}{m-j}[j=k]\\
=f(k)
$$



然后我们把$g(k)$的closed-form带入进来.
$$
g(k)=\frac{(m-k)^{n-kS}}{(S!)^k(n-kS)!}\\
f(k)
=\sum_{i=k}^m \binom{m-k}{i-k}(-1)^{i-k}g(i)\\

=\sum_{i=k}^m
	\binom{m-k}{i-k}(-1)^{i-k}
	\frac{(m-i)^{n-iS}}{(S!)^i(n-iS)!}\\
	
ans
=\sum_{k=0}^m\binom{m}{k}f(k)w_k\\
=\sum_{k=0}^m\binom{m}{k}w_k\sum_{i=k}^m
	
		\binom{m-k}{i-k}(-1)^{i-k}
		\frac{(m-i)^{n-iS}}{(S!)^i(n-iS)!}\\
$$



所以目前我们有了个$O(m^2+mlog(mod))$的做法.之后随便做一下下标的变换,转换成卷积形式就优化到$O(mlog(mod)+mlogm)$了,然后卡卡常数就可以过了qwq.



```cpp
//(40+10)pts.O(m^2)
#include <bits/stdc++.h>
typedef long long Int;
const int M=100000+1;
const int N=10000000+1;
const Int G=3LL;
const Int mod=1004535809LL;
Int read(){
	Int x=0;char c;
	do{c=getchar();}while(!isdigit(c));
	do{x=x*10+c-'0';c=getchar();}while(isdigit(c));
	return x;
}
inline Int fix(Int x){ return (x%mod+mod)%mod; }
Int qpow(Int a,Int p=mod-2){
	Int r=1; a=fix(a); while(p){
		if(p&1) r=r*a%mod;
		a=a*a%mod; p>>=1;
	} return r;
}
int n,m,S;
Int inv[N],ifc[N],fac[N],w[N];
inline Int binom(int n,int m){ return fac[n]*ifc[m]%mod*ifc[n-m]%mod; }

Int tg[M]; bool vg[M];
Int g(int k){
	if(k*S>n) return 0;
	if(vg[k]) return tg[k];
	Int r=qpow(qpow(fac[S],k)*fac[n-k*S]);
	vg[k]=1; return tg[k]=r*qpow(m-k,n-k*S)%mod;
}
Int f(int k){
	if(k*S>n) return 0;
	Int r=0,tmp; for(int i=k;i<=m;i++){
		tmp=binom(m-k,i-k)*g(i)%mod;
		if((i-k)%2==1) r=(r-tmp+mod)%mod;
		else r=(r+tmp)%mod;
	}
	return r;
}

int main(){
	n=read();m=read();S=read();
	for(int i=0;i<=m;i++) w[i]=read();
	inv[1]=ifc[0]=ifc[1]=fac[0]=fac[1]=1; for(int i=2,r=std::min(n+m,N-1);i<=r;i++){
		inv[i]=fix(-(mod/i)*inv[mod%i]);
		fac[i]=fac[i-1]*i%mod;
		ifc[i]=ifc[i-1]*inv[i]%mod;
	}
	Int ans=0;
	for(int k=0;S*k<=n&&k<=m;k++) if(w[k])
		ans=(ans+f(k)*binom(m,k)%mod*w[k]%mod)%mod;
	std::cout<<fac[n]*ans%mod<<std::endl;
	std::cerr<<1.0*clock()/CLOCKS_PER_SEC<<std::endl;
	return 0;
}
```



```cpp
//AC 100pts,NTT
// gu gu gu
```

