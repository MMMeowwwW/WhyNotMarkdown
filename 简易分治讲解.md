### 分治qwq

>这里是afoier spinach@bhsf
>
>这次带来的是一个简易的分治教程…
>
>可以去[这里](<https://www.luogu.com.cn/problem/U66865>)试试自己实现的是否正确.



#### k维偏序问题.

$n​$个$k​$维向量$\vec v_i=(a_1,a_2,a_3\dots a_k)​$,称$\vec v_i\lt \vec v_j​$当且仅当$\forall p\leq k,\vec v_i[p]\lt \vec v_j[p]​$.求$f(k)=\sum[\vec v_i\lt \vec v_k]​$

---

##### 做法

分治,solve(p,q,k)表示考虑前k维,可能有贡献的向量集合是p,查询操作集合是q.

考虑第$k$维的可能取值是$[L_k,R_k)$那么我们取$mid=\frac{L_k+R_k}{2}$.把询问,修改修改的向量分别按照第$k$维与$mid$的大小关系分类,分成$(pl,pr),(ql,qr)$分别为第$k$为$\{p\mid p[k]\lt mid\},\{p\mid p[k]\geq mid\}$和$\{q\mid q[k]\lt mid\},\{q\mid q[k]\geq mid\}$.



考虑$pl$中的元素对于$ql,qr$中的询问的贡献,分别为$solve(pl,ql,k),solve(ql,qr,k-1)$前一种情况因为都是$v[k]\lt mid$所以需要继续考虑第$k$维的问题,后面一种第$k$维分别在$mid$两侧,第$k$维的约束已经满足了,于是可以仅仅考虑前$k-1$维.再来考虑$pr$中元素对于$ql,qr$的贡献,这里简单一些$pr$的贡献则只有$solve(pr,qr,k)$.

给出一个伪代码,实现的时候需要稍微处理一下免得排序把询问的顺序排乱了…其实只要存一下询问编号就行了.



考虑一下$solve$的求解递归树,每次进入更深的子树$|p|,|q|$都会减半,复杂度看起来有保证,而边界情况则是$|p|\lt 2\and |q|\lt 2$此时暴力求解即可.

```csharp
solve(p,q,k){
	ret=[0]*size(q); sort(p,k);sort(q,k);

	mid=size(q)/2; ql=q[1,mid];qr=q-ql;
	pl=p.select(v[k]<q[mid+1][k]);pr=p-pl;
    
	ret+=[0]*mid+solve(pl,qr,k-1);
	ret+=solve(pl.ql,k);
	ret+=[0]*mid+solve(pr,qr,k);

	return ret;
}
```

----

##### 实现

```cpp
#include <bits/stdc++.h>
const int N=100000+10;
const int K=4;

struct Vector{
	int _a[K]; Vector(){ for(int i=0;i<K;i++) _a[i]=0; }
	int& operator[](int k){return _a[k-1];}
	const int& operator[](int k)const{return _a[k-1];}
	struct Compare{
		int k; Compare(int x):k(x){}
		bool operator()(const Vector&a,const Vector&b)const{ return a[k]<b[k]; }
	};
};
typedef std::vector<Vector> Vec;
typedef std::vector<int> Vint;

// f(i)=sum([vj<vi] for j in[1,n])
Vint force(const Vec&v){
	Vint ret=Vint(v.size(),0);
	for(int i=0;i<v.size();i++) for(auto const&x:v){
		int r=0; for(int j=1;j<=K;j++) r+=x[j]<v[i][j];
		ret[i]+=(r==K);
	}
	return ret;
}
Vec sub(const Vec&a,int l,int r){ Vec t; while(l<r) t.push_back(a[l++]); return t; }

struct qwq{
	int k; const Vec&p; qwq(int x,const Vec&y):k(x),p(y){}
	bool operator()(int a,int b)const{ return p[a][k]<p[b][k]; }
};
static int GLOBAL_COUNT=0;
Vint solve(Vec p,Vec q,int k){
	Vint ret=Vint(q.size(),0),tmp,at(q.size(),0);
	if(k==0) return Vint(q.size(),p.size());
	
	if(p.size()<2||q.size()<2){
		for(int i=0;i<q.size();i++) for(auto const &x:p){
			GLOBAL_COUNT++;
			int r=0; for(int j=1;j<=k;j++) r+=(x[j]<q[i][j]);
			ret[i]+=(r==k);
		}
		return ret;
	}

	at=Vint(q.size(),0); for(int i=0;i<q.size();i++) at[i]=i;
	std::sort(at.begin(),at.end(),qwq(k,q));
	std::sort(q.begin(),q.end(),Vector::Compare(k));

	int mid=q.size()/2; Vec ql=sub(q,0,mid),qr=sub(q,mid,q.size());
	Vec pl,pr; for(auto const &x:p) (x[k]<q[mid][k]?pl:pr).push_back(x);
	tmp=solve(pl,qr,k-1); for(int i=0;i<qr.size();i++) ret[at[i+mid]]+=tmp[i];
	tmp=solve(pl,ql,k); for(int i=0;i<ql.size();i++) ret[at[i]]+=tmp[i];
	tmp=solve(pr,qr,k); for(int i=0;i<qr.size();i++) ret[at[i+mid]]+=tmp[i];

	return ret;
} // divide and conquer
inline Vint solve(const Vec &v){ return solve(v,v,K); }


int read(){
	int x=0;char c;
	do{c=getchar();}while(!isdigit(c));
	do{x=x*10+c-'0';c=getchar();}while(isdigit(c));
	return x;
}
void output(const std::string& info,const Vint&v){
	fprintf(stderr,"%s(size=%d)\t[",info.c_str(),v.size());
	for(int i:v) fprintf(stderr,"%d,",i);
	fprintf(stderr,"]\n");
}

int main(){
	//freopen("in","r",stdin);
	int n=read(); Vector t; Vec a;
	for(int i=0;i<n;i++){
		for(int j=1;j<=K;j++) t[j]=read();
		a.push_back(t);
	}

	Vint frc=force(a); output("force",frc);
	Vint dnc=solve(a); output("divide",dnc);

    
	int qwq=0;
	for(int i=0;i<n;i++) qwq+=(frc[i]==dnc[i]);
	printf("equiv=%d\n",qwq==n);

	fprintf(stderr,"force:%d\n",GLOBAL_COUNT);

	return 0;
}
```



```python
#generator.py
from random import randint as rng
n,k,lim=10000,4,1000
with open('in','w') as f:
    print(n,file=f)
    for i in range(n):
        for j in range(k): print(rng(0,lim),file=f,end=' ')
        print('\n',end='',file=f)
```



---

##### 复杂度

$$
T(n,k)=T(n,k-1)+2T(\frac{n}{2},k)\\
T(n,1)=nlogn\\
T(n,2)=nlogn+2T(\frac{n}{2},1)=nlog^2n\\

T(n,k)=nlog^kn
$$

----

##### reminders

$k​$极大使得$log^k n\geq kn​$时就使用$O(kn^2)​$的暴力求解吧qwq.

高维偏序的其他玩法?bitset.逐位筛选就行了…$O(\frac{kn^2}{w}+kn)​$的.

